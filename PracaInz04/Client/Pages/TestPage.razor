@page "/testpage"
@using System.Diagnostics
@implements IDisposable

@inject StateService SService
@inject LocalStorageManager LSManager
@inject IndexedDbManager IDbManager
@inject IndexedDbContext IndexedDbContext
@inject NavigationManager NavigationManager
@inject ImageProcessing ImageProc
@inject IJSRuntime JS

<div class="container-fluid bg-primary h-100">
	<div class="row bg-success h-100">
        @*had h-100*@
		<div class="col-md-9 bg-warning d-flex align-items-center justify-content-center mh-100">
            @if(ImageName!=null && ImageName!="")
            {
                @*<img class="mw-100 mh-100" src="images/placeholder.svg" alt="Card image cap">*@
                @*<img class="mw-100 mh-100" width="750" src="images/cat01_500.jpg" alt="Card image cap"> *@
                @*<img class="mw-100 mh-100" width="750" src="@testSrc2" alt="Card image cap"> *@

                @*<img @ref="imgReference" hidden src="images/cat01_500.jpg"> *@
                @*<img @ref="imgReference" hidden src="@testSrc"> *@
                @*<BECanvas Width="500" Height="500" @ref="_canvasReference" ></BECanvas>*@

                <SKCanvasView 
                    @ref="skiaView" 
                    @onmousewheel="OnMouseWheel"
                    @onmousedown="OnMouseDown"
                    @onmousemove="OnMouseMove"
                    @onmouseup="OnMouseUp"
                    @onmouseout="OnMouseOut"
                    @onclick="OnClick"
                    OnPaintSurface="@OnPaintSurface"
                    IgnorePixelScaling="false" 
                    @attributes="CanvasAttributes" 
                    class="border mw-100 mh-100 w-100 h-100"
                    style="image-rendering: pixelated;"/>
            }
            else
            {
                <div class="text-center">
                    <UploadImageComponent></UploadImageComponent>
                    <div class="btn btn-light my-2" @onclick='()=>NavigationManager.NavigateTo("imagelist2")'>Choose image from Image List</div>
                </div>
            }
		</div>
		<div class="col-md-3 bg-info">
			<Tools2Component></Tools2Component>
            <br />
            <br />
            <button class="btn btn-primary" @onclick="ResetPanOffset">Center image</button>
            <br />
            <br />
            <button class="btn btn-primary" @onclick="ResetScale">Reset scale</button>
            <br />
            <br />
            <button class="btn btn-primary" @onclick="CropImage">Crop image</button>
		</div>
	</div>
</div>

@code {
    // initialize imageName in local storage on startup
    public string? ImageName { get; set; }
    public ImageResized imageResized { get; set; }
    public SKBitmap sKBitmap { get; set; }

    public string testSrc { get; set; }
    public string testSrc2 { get; set; }
    SKCanvasView skiaView = null!;
    float scrollScale = 1;
    bool isDown = false;
    SKRect selectRect = SKRect.Empty;
    SKRect selectRectOriginal = SKRect.Empty;
    System.Timers.Timer clickTime = new System.Timers.Timer(100);
    bool isClick = true;
    SKRect bitmapRect = SKRect.Empty;
    float windowDPR = 1;
    (float x, float y) selectOffset;
    (float x, float y) selectOffsetOriginal;
    bool scrollScaleChanged = true;
    float distance;
    int selectCornerRadius = 12;
    private DotNetObjectReference<TestPage>? dotNetHelper;
    bool isMiddle = false;
    SKRect panRect = SKRect.Empty;
    (float x, float y) panOffset;

    private Dictionary<string, object> CanvasAttributes { get; set; }
    //new()
    //{
    //    { "width", "500" },
    //    { "height", "500" }
    //};

    private void CropImage()
    {
        float viewToBitmapRatio = (float)sKBitmap.Width / bitmapRect.Width;

        //(float x, float y) scaledOffset;
        //scaledOffset.x = selectOffset.x * viewToBitmapRatio;
        //scaledOffset.y = selectOffset.y * viewToBitmapRatio;

        // swap selection start and end
        if(selectRect.Left > selectRect.Right)
        {
            float tLeft = selectRect.Left;
            selectRect.Left = selectRect.Right;
            selectRect.Right = tLeft;
        }

        if(selectRect.Top > selectRect.Bottom)
        {
            float tTop = selectRect.Top;
            selectRect.Top = selectRect.Bottom;
            selectRect.Bottom = tTop;
        }

        // dodac poczatek bitmapy do selectRect
        selectRect.Left -= bitmapRect.Left;
        selectRect.Top -= bitmapRect.Top;
        selectRect.Right -= bitmapRect.Left;
        selectRect.Bottom -= bitmapRect.Top;

        // sortuj wierzcholki?
        SKRect cropRect = SKRect.Empty;
        cropRect.Left = selectRect.Left * viewToBitmapRatio;
        cropRect.Top = selectRect.Top * viewToBitmapRatio;
        cropRect.Right = selectRect.Right * viewToBitmapRatio;
        cropRect.Bottom = selectRect.Bottom * viewToBitmapRatio;

        SKRect dest = new SKRect(0, 0, cropRect.Width, cropRect.Height);

        SKBitmap croppedBitmap = new SKBitmap((int)cropRect.Width, (int)cropRect.Height);

        //Console.WriteLine($"viewToBitmapRatio: {viewToBitmapRatio}");
        //Console.WriteLine($"sKBitmap ratio: {(float)sKBitmap.Width / sKBitmap.Height}");
        //Console.WriteLine($"bitmapRect ratio: {bitmapRect.Width / bitmapRect.Height}");
        //Console.WriteLine($"selectRect: {selectRect.Width}, {selectRect.Height}");
        //Console.WriteLine($"        : ({selectRect.Left}, {selectRect.Top})");
        //Console.WriteLine($"        : ({selectRect.Right}, {selectRect.Bottom})");

        //Console.WriteLine($"sKBitmap: {sKBitmap.Width}, {sKBitmap.Height}");
        //Console.WriteLine($"cropRect: {cropRect.Width}, {cropRect.Height}");
        //Console.WriteLine($"        : ({cropRect.Left}, {cropRect.Top})");
        //Console.WriteLine($"        : ({cropRect.Right}, {cropRect.Bottom})");
        //Console.WriteLine($"croppedBitmap: {croppedBitmap.Width}, {croppedBitmap.Height}");

        using (SKCanvas canvas = new SKCanvas(croppedBitmap))
        {
            canvas.DrawBitmap(sKBitmap, cropRect, dest);
        }
        sKBitmap = croppedBitmap;

        scrollScale = 1;
        selectRect = SKRect.Empty;

        skiaView.Invalidate();
    }

    private void ResetPanOffset()
    {
        panOffset = (0, 0);
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void ResetScale()
    {
        scrollScale = 1;
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        SKImageInfo info = e.Info;
        SKSurface surface = e.Surface;
        SKCanvas canvas = surface.Canvas;

        canvas.Clear();

        // nie obliczac od nowa, jezeli nie zmieniła się scroll skala
        //if (scrollScaleChanged || isMiddle)
        //{
            float scale = Math.Min((float)info.Width / sKBitmap.Width,
                                  (float)info.Height / sKBitmap.Height);
            float x = (info.Width - scale * scrollScale * sKBitmap.Width) / 2;
            float y = (info.Height - scale * scrollScale * sKBitmap.Height) / 2;
            float x2 = x + scale * scrollScale * sKBitmap.Width;
            float y2 = y + scale * scrollScale * sKBitmap.Height;
            bitmapRect = new SKRect(x, y, x2, y2);

            float panX = panRect.Right - panRect.Left;
            float panY = panRect.Bottom - panRect.Top;
            panOffset.x += panX / scrollScale;
            panOffset.y += panY / scrollScale;

            panRect.Left = panRect.Right;
            panRect.Top = panRect.Bottom;

            bitmapRect.Left += panOffset.x * scrollScale;
            bitmapRect.Top += panOffset.y * scrollScale;
            bitmapRect.Right += panOffset.x * scrollScale;
            bitmapRect.Bottom += panOffset.y * scrollScale;
        //}
        scrollScaleChanged = false;

        canvas.DrawBitmap(sKBitmap, bitmapRect);

        float middleX = info.Width / 2;
        float middleY = info.Height / 2;
        float crossLength = 10;
        SKPaint crossPaint = new SKPaint()
            {
                Style = SKPaintStyle.Stroke,
                StrokeWidth = 2,
                Color = SKColors.White
            };
        canvas.DrawLine(middleX - crossLength, middleY, middleX + crossLength, middleY, crossPaint);
        canvas.DrawLine(middleX, middleY  - crossLength, middleX, middleY  + crossLength, crossPaint);


        if (selectRect != SKRect.Empty)
        {
            if(!isDown)
                AdjustSelection();

            SKColor selectionColor = SKColors.White;
            SKPaint paint = new SKPaint()
                {
                    Style = SKPaintStyle.Stroke,
                    StrokeWidth = 3,
                    PathEffect = SKPathEffect.CreateDash(new float[] { 4, 4 }, 0),
                    Color = selectionColor
                };
            canvas.DrawRect(selectRect, paint);

            SKPaint circlePaint = new SKPaint()
                {
                    Style = SKPaintStyle.Fill,
                    IsAntialias = true,
                    Color = selectionColor
                };


            canvas.DrawCircle(selectRect.Left, selectRect.Top, selectCornerRadius, circlePaint);
            //canvas.DrawCircle(selectRect.Left, selectRect.Bottom, selectCornerRadius, circlePaint);
            //canvas.DrawCircle(selectRect.Right, selectRect.Top, selectCornerRadius, circlePaint);
            canvas.DrawCircle(selectRect.Right, selectRect.Bottom, selectCornerRadius, circlePaint);
        }
        Console.WriteLine("painted");
    }

    private void OnMouseWheel(WheelEventArgs e)
    {
        if(e.DeltaY > 0)
        {
            if (scrollScale < 2)
            {
                scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
            }
        }
        else
        {
            if (scrollScale > 0.2)
            {
                scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
            }
        }
        Console.WriteLine($"OnMouseWheel: {e.DeltaY}, {scrollScale}");
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        //Console.WriteLine($"{e.Button}");
        // middle mouse button
        if (e.Button == 1)
        {
            isMiddle = true;
            panRect.Left = (float)e.OffsetX;
            panRect.Top = (float)e.OffsetY;
        }
        else if(e.Button == 0)
        {
            clickTime.Start();
            Console.WriteLine("timer start");
            isDown = true;
            (float scaledOffsetX, float scaledOffsetY) = ScaleOffsets((float)e.OffsetX, (float)e.OffsetY);
            Console.WriteLine($"OnMouseDown: scaledOffsetX: {scaledOffsetX}, scaledOffsetY: {scaledOffsetY}");
            distance = Distance(selectRect.Right, selectRect.Bottom,
                                scaledOffsetX, scaledOffsetY);
            if (distance > selectCornerRadius)
            {
                distance = Distance(selectRect.Left, selectRect.Top,
                                    scaledOffsetX, scaledOffsetY);
                if (distance > selectCornerRadius)
                {
                    SetSelectionStart(scaledOffsetX, scaledOffsetY);
                    GetSelectionOffset();
                }
                else
                {
                    ReverseSelection();
                    GetSelectionOffset();
                }
            }
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        (float scaledOffsetX, float scaledOffsetY) = ScaleOffsets((float)e.OffsetX, (float)e.OffsetY);
        if (isDown)
        {
            SetSelectionEnd(scaledOffsetX, scaledOffsetY);
            Console.WriteLine($"OnMouseMove: scaledOffsetX: {scaledOffsetX}, scaledOffsetY: {scaledOffsetY}");
            SetSelectOriginal();
            skiaView.Invalidate();
        }

        if(isMiddle)
        {
            panRect.Right = (float)e.OffsetX;
            panRect.Bottom = (float)e.OffsetY;
            skiaView.Invalidate();
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        isDown = false;
        isMiddle = false;
        Console.WriteLine($"OnMouseUp: e.OffsetX: {e.OffsetX * windowDPR}, e.OffsetY: {e.OffsetY * windowDPR}");
    }

    private void OnMouseOut(MouseEventArgs e)
    {
        clickTime.Stop();
        Console.WriteLine("timer stop");
        isDown = false;
        isMiddle = false;
        Console.WriteLine("Out:");
    }

    // timer between down-up, short click resets rect
    private void OnClick(MouseEventArgs e)
    {
        clickTime.Stop();
        Console.WriteLine("timer stop");
        Console.WriteLine("Click");
        if (isClick)
        {
            selectRect = SKRect.Empty;
            skiaView.Invalidate();
        }
        isClick = true;
    }

    private void SetBitmapOffset(double offsetX, double offsetY)
    {
        
    }

    private float Distance( float x1, float y1, float x2, float y2)
    {
        return (float)Math.Sqrt(Math.Pow(x1-x2, 2) + Math.Pow(y1-y2, 2));
    }

    private void AdjustSelection()
    {
        // musimy obliczyc selectRectOriginal dla scrollscale = 1
        // czyli podzielic selectRect przez scrollscale
        selectRect.Left = selectRectOriginal.Left * scrollScale;
        selectRect.Top = selectRectOriginal.Top * scrollScale;
        selectRect.Right = selectRectOriginal.Right * scrollScale;
        selectRect.Bottom = selectRectOriginal.Bottom * scrollScale;

        // tu pewnie problem ze zmianą selekcji przy zaznaczeniu SE -> NW
        selectRect.Right -= selectRect.Left;
        selectRect.Bottom -= selectRect.Top;
        selectRect.Left = 0;
        selectRect.Top = 0;

        selectRect.Left += bitmapRect.Left;
        selectRect.Top += bitmapRect.Top;
        selectRect.Right += bitmapRect.Left;
        selectRect.Bottom += bitmapRect.Top;

        selectOffset.x = selectOffsetOriginal.x * scrollScale;
        selectOffset.y = selectOffsetOriginal.y * scrollScale;

        selectRect.Left += selectOffset.x;
        selectRect.Top += selectOffset.y;
        selectRect.Right += selectOffset.x;
        selectRect.Bottom += selectOffset.y;
    }

    private (float scaledOffsetX, float scaledOffsetY) ScaleOffsets(float eOffsetX, float eOffsetY)
    {
        return ((float)eOffsetX * windowDPR, (float)eOffsetY * windowDPR);
    }

    private void ReverseSelection()
    {
        float left = selectRect.Left;
        float top = selectRect.Top;

        selectRect.Left = selectRect.Right;
        selectRect.Right = left;
        selectRect.Top = selectRect.Bottom;
        selectRect.Bottom = top;
    }

    private void GetSelectionOffset()
    {
        selectOffset.x = selectRect.Left - bitmapRect.Left;
        selectOffset.y = selectRect.Top - bitmapRect.Top;
        Console.WriteLine($"b:({bitmapRect.Left}, {bitmapRect.Top})\n"+
                                $"s:({selectRect.Left}, {selectRect.Top})\n"+ 
                                $"o: ({selectOffset.x}, {selectOffset.y}))");
    }

    private void SetSelectionStart(double offsetX, double offsetY)
    {
        selectRect.Left = (float)Math.Max(bitmapRect.Left, offsetX);
        selectRect.Top = (float)Math.Max(bitmapRect.Top, offsetY);

        selectRect.Left = (float)Math.Min(bitmapRect.Right, selectRect.Left);
        selectRect.Top = (float)Math.Min(bitmapRect.Bottom, selectRect.Top);
    }

    private void SetSelectionEnd(double offsetX, double offsetY)
    {
        selectRect.Right = (float)Math.Min(bitmapRect.Right, offsetX);
        selectRect.Bottom = (float)Math.Min(bitmapRect.Bottom, offsetY);

        selectRect.Right = (float)Math.Max(bitmapRect.Left, selectRect.Right);
        selectRect.Bottom = (float)Math.Max(bitmapRect.Top, selectRect.Bottom);
    }

    private void SetSelectOriginal()
    {
        selectRectOriginal.Left = selectRect.Left / scrollScale;
        selectRectOriginal.Top = selectRect.Top / scrollScale;
        selectRectOriginal.Right = selectRect.Right / scrollScale;
        selectRectOriginal.Bottom = selectRect.Bottom / scrollScale;

        selectOffsetOriginal.x = selectOffset.x / scrollScale;
        selectOffsetOriginal.y = selectOffset.y / scrollScale;
    }

    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }

    [JSInvokable]
    public void SetWindowDPR(float pr)
    {
        windowDPR = pr;
        Console.WriteLine("SetWindowDPR");
    }

    protected override async Task OnInitializedAsync()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
        //windowDPR = await JS.InvokeAsync<float>("windowDevicePixelRatio");
        await JS.InvokeVoidAsync("WindowDPRHelper.callupdatePixelRatio", dotNetHelper);

        //windowDPR = await JS.InvokeAsync<float>("windowDevicePixelRatio");
        //windowDPR = await JS.InvokeAsync<float>("callUpdatePixelRatio");

        Console.WriteLine($"window.devicePixelRatio: {windowDPR}");
        //ImageName = SService.ImageName;
        clickTime.Elapsed += (sender, e) => {isClick = false;};
        var openDbResult = await IndexedDbContext.OpenIndexedDb();
        ImageName = await LSManager.GetImageName();
        if(ImageName != null)
        {
            Console.WriteLine($"ImageName: {ImageName}");
            imageResized = await IDbManager.FetchImageResized(ImageName);
            if(imageResized != null)
            {
                //sKBitmap = SKBitmap.Decode(imageResized.ImageArray);

                //testSrc = await ImageProc.GetImageURL(imageResized.ImageArray);
            }

            var imageData = await IDbManager.FetchImageData(ImageName);
            if(imageData != null)
            {
                sKBitmap = SKBitmap.Decode(imageData.ImageArray);

                //int w = 1000;
                //CanvasAttributes = new Dictionary<string, object> 
                //{{ "width", $"{w}" },
                //{ "height", $"{(int)(((float)w/sKBitmap.Width)*sKBitmap.Height)}" }};

                //CanvasAttributes = new Dictionary<string, object> 
                //{{ "width", $"{sKBitmap.Width}" },
                //{ "height", $"{sKBitmap.Height}" }};

                testSrc2 = await ImageProc.GetImageURL(imageData.ImageArray);
            }
        }

        //testSrc = await TestStuff();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //if (firstRender)
        //{
        //    await SetupBECanvas();
        //}
        base.OnAfterRender(firstRender);
    }

    //private void OnMouseWheel(WheelEventArgs e)
    //{
    //    // scroll up / zoom in
    //    //if(e.DeltaY > 0)
    //    //{
    //    //    if (scrollScale < 10)
    //    //    {
    //    //        if (scrollScale < 1)
    //    //            scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
    //    //        else
    //    //            scrollScale = (float)Math.Round(scrollScale + 1, 0);
    //    //    }
    //    //}
    //    //else
    //    //{
    //    //    if (scrollScale > 0.2)
    //    //    {
    //    //        if (scrollScale <= 1)
    //    //            scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
    //    //        else
    //    //            scrollScale = (float)Math.Round(scrollScale - 1, 0);
    //    //    }
    //    //}

    //    if(e.DeltaY > 0)
    //    {
    //        if (scrollScale < 2)
    //        {
    //            scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
    //        }
    //    }
    //    else
    //    {
    //        if (scrollScale > 0.2)
    //        {
    //            scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
    //        }
    //    }
    //    Console.WriteLine($"{e.DeltaY}, {scrollScale}");
    //    skiaView.Invalidate();
    //}

    //public async Task<string> TestStuff()
    //{
    //    var testImage = await IDbManager.FetchImageResized(ImageName);
    //    var imageSrc = await ImageProc.GetImageURL(testImage.ImageArray);

    //    return imageSrc;
    //}

    //private Canvas2DContext _context;
    //protected BECanvasComponent _canvasReference;
    //protected ElementReference imgReference;

    //public async Task SetupBECanvas()
    //{
    //    if(_canvasReference != null)
    //        _context = await _canvasReference.CreateCanvas2DAsync();
    //    //await this._context.SetFillStyleAsync("green");

    //    //await this._context.FillRectAsync(10, 100, 100, 100);

    //    //await this._context.SetFontAsync("48px serif");
    //    //await this._context.StrokeTextAsync("Hello Blazor!!!", 10, 100);

    //    if(_context != null)
    //        await _context.DrawImageAsync(imgReference,0,0);

    //        StateHasChanged();
    //}

}