@page "/testpage"
@using System.Diagnostics
@implements IDisposable

@inject StateService SService
@inject LocalStorageManager LSManager
@inject IndexedDbManager IDbManager
@inject IndexedDbContext IndexedDbContext
@inject NavigationManager NavigationManager
@inject ImageProcessing ImageProc
@inject IJSRuntime JS

<div class="container-fluid bg-primary h-100">
    @*<div hidden @onkeypress="OnKeyPressed"></div>*@
    @*<input type="text" @onkeydown="OnKeyPressed"/>*@
	<div class="row bg-success h-100">
        @*had h-100*@
		<div class="col-md-9 bg-warning d-flex align-items-center justify-content-center mh-100">
            @if(ImageName!=null && ImageName!="")
            {
                @*<img class="mw-100 mh-100" src="images/placeholder.svg" alt="Card image cap">*@
                @*<img class="mw-100 mh-100" width="750" src="images/cat01_500.jpg" alt="Card image cap"> *@
                @*<img class="mw-100 mh-100" width="750" src="@testSrc2" alt="Card image cap"> *@
                
                @*<img @ref="imgReference" hidden src="images/cat01_500.jpg"> *@
                @*<img @ref="imgReference" hidden src="@testSrc"> *@
                @*<BECanvas Width="500" Height="500" @ref="_canvasReference" ></BECanvas>*@

                <SKCanvasView 
                    @ref="skiaView" 
                    @onmousewheel="OnMouseWheel"
                    @onmousedown="OnMouseDown"
                    @onmousemove="OnMouseMove"
                    @onmouseup="OnMouseUp"
                    @onmouseout="OnMouseOut"
                    @onclick="OnClick"
                    OnPaintSurface="@OnPaintSurface"
                    IgnorePixelScaling="false" 
                    @attributes="CanvasAttributes" 
                    class="border mw-100 mh-100 w-100 h-100"
                    style="image-rendering: pixelated;"/>
            }
            else
            {
                <div class="text-center">
                    <UploadImageComponent></UploadImageComponent>
                    <div class="btn btn-light my-2" @onclick='()=>NavigationManager.NavigateTo("imagelist2")'>Choose image from Image List</div>
                </div>
            }
		</div>
		<div class="col-md-3 bg-info d-flex flex-column align-items-center">
			@*<Tools2Component></Tools2Component>*@
            
            <button class="btn btn-primary m-2 w-50" @onclick="ResetPanOffset">Center image</button>
            <button class="btn btn-primary m-2 w-50" @onclick="ResetScale">Reset scale</button>
            <button class="btn btn-primary m-2 w-50" @onclick="CropImage">Crop image</button>
            <button class="btn btn-primary m-2 w-50" @onclick="RotateImage">Rotate image</button>
            <button class="btn btn-primary m-2 w-50" @onclick="() => FlipImage(true)">Flip horizontally</button>
            <button class="btn btn-primary m-2 w-50" @onclick="() => FlipImage(false)">Flip vertically</button>
            @*<button class="btn btn-primary m-2 w-50" @onclick="() => TiltImage(5)">Tilt image</button>*@
            
            @*<label for="customRange1" class="form-label">Tilt angle</label>
            <input 
                @bind="tiltAngle" @bind:event="oninput" @on="() => Console.WriteLine(msg)"
                min="0" max="90"
                type="range" class="form-range" id="customRange1">
            <p>@tiltAngle</p>*@

            <label for="customRange1" class="form-label">Tilt image</label>
            <input 
                value="@tiltAngle" @oninput="OnTiltAngleChange"
                min="@minAngle" max="@maxAngle"
                type="range" class="form-range m-2 w-75" id="customRange1">
            <input 
                value="@tiltAngle"  @onchange="OnTiltAngleChange"
                type="number" class="form-control m-2 w-25" id="formControlInput1">
            <button class="btn btn-primary m-2 w-50" @onclick="ResetTilt">Reset tilt</button>
		</div>
	</div>
</div>

@code {
    // initialize imageName in local storage on startup
    public string? ImageName { get; set; }
    public ImageResized imageResized { get; set; }
    public SKBitmap sKBitmap { get; set; }

    public string testSrc { get; set; }
    public string testSrc2 { get; set; }
    SKCanvasView skiaView = null!;
    float scrollScale = 1;
    bool isDown = false;
    SKRect selectRect = SKRect.Empty;
    SKRect selectRectOriginal = SKRect.Empty;
    System.Timers.Timer clickTime = new System.Timers.Timer(100);
    bool isClick = true;
    SKRect bitmapRect = SKRect.Empty;
    float windowDPR = 1;
    // mozna uzyc selectRect.Location zmiast selectOffset 
    (float x, float y) selectOffset;
    (float x, float y) selectOffsetOriginal;
    bool scrollScaleChanged = true;
    float distance;
    int selectCornerRadius = 12;
    private DotNetObjectReference<TestPage>? dotNetHelper;
    bool isMiddle = false;
    SKRect panRect = SKRect.Empty;
    (float x, float y) panOffset;
    List<SKBitmap> lastBitmaps = new List<SKBitmap>();
    int currentIndex = -1;
    int imax = 10;
    bool rotateSelect = false;
    float tiltAngle = 0;
    bool tilting = false;
    SKPoint[] tiltedBitmapCorners;
    SKRect tiltedBitmapRect;
    bool makeSelectRect = false;
    int minAngle = -90;
    int maxAngle = 90;

    private Dictionary<string, object> CanvasAttributes { get; set; }
    //new(){{ "width", "500" },{ "height", "500" }};

    private void SetUpNewSelectRect()
    {
        SetSelectionOffset();
        SetSelectOriginal();
    }

    private void OnTiltAngleChange(ChangeEventArgs e)
    {
        tiltAngle = Convert.ToInt32(e.Value);
        tiltAngle = Math.Min(tiltAngle, maxAngle);
        tiltAngle = Math.Max(tiltAngle, minAngle);
        if (tiltAngle == 0)
            ResetTilt();
        else
            TiltImage();
        Console.WriteLine(e.Value);

    }

    private void DisplayPoint(SKPoint p)
    {
        Console.WriteLine($"({p.X}, {p.Y})");
        Console.WriteLine($"({p.X}, {p.Y})");
    }

    private SKPoint? IntersectionPoint(SKPoint A, SKPoint B, SKPoint C, SKPoint D)
    {
        // Line AB represented as a1x + b1y = c1 
        double a1 = B.Y - A.Y;
        double b1 = A.X - B.X;
        double c1 = a1 * (A.X) + b1 * (A.Y);

        // Line CD represented as a2x + b2y = c2 
        double a2 = D.Y - C.Y;
        double b2 = C.X - D.X;
        double c2 = a2 * (C.X) + b2 * (C.Y);

        double determinant = a1 * b2 - a2 * b1;

        if (determinant == 0)
        {
            // The lines are parallel.
            //return new SKPoint(float.MaxValue, float.MaxValue);
            return null;
        }
        else
        {
            double x = (b2 * c1 - b1 * c2) / determinant;
            double y = (a1 * c2 - a2 * c1) / determinant;
            return new SKPoint((float)x, (float)y);
        }
    }

    private void GenerateSelectRect(SKPoint S)
    {
        //Console.WriteLine("tiltedBitmapCorners:");
        //DisplayPoint(tiltedBitmapCorners[0]);
        //DisplayPoint(tiltedBitmapCorners[1]);
        //DisplayPoint(tiltedBitmapCorners[2]);
        //DisplayPoint(tiltedBitmapCorners[3]);

        SKPoint Atb = tiltedBitmapCorners[0];
        SKPoint Btb = tiltedBitmapCorners[1];
        SKPoint B = new SKPoint(tiltedBitmapRect.Right, tiltedBitmapRect.Top);
        SKPoint? ip1 = IntersectionPoint(Atb, Btb, S, B);

        SKPoint Dtb = tiltedBitmapCorners[3];
        SKPoint A = new SKPoint(tiltedBitmapRect.Left, tiltedBitmapRect.Top);
        SKPoint? ip2 = IntersectionPoint(Atb, Dtb, S, A);
        SKPoint startPoint = new SKPoint();
        SKPoint endPoint = new SKPoint();
        if (ip1 != null && ip2 != null)
        {
            float d1 = SKPoint.Distance((SKPoint)ip1, S);
            float d2 = SKPoint.Distance((SKPoint)ip2, S);

            //Console.WriteLine($"d1: {d1}, d2: {d2}");

            if (d1 < d2)
                startPoint = (SKPoint)ip1;
            else
                startPoint = (SKPoint)ip2;

            SKPoint dV = S - startPoint;
            endPoint = S + dV;

            selectRect = new SKRect(startPoint.X, startPoint.Y, endPoint.X, endPoint.Y);
            OrderSelectRect();
            SetUpNewSelectRect();
        }
    }

    private void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        SKImageInfo info = e.Info;
        SKSurface surface = e.Surface;
        SKCanvas canvas = surface.Canvas;
        float infoMiddleX = info.Width / 2;
        float infoMiddleY = info.Height / 2;

        canvas.Clear();

        // nie obliczac od nowa, jezeli nie zmieniła się scroll skala
        //if (scrollScaleChanged || isMiddle)
        //{

        // calculate bitmapRect
        float scale = Math.Min((float)info.Width / sKBitmap.Width,
                              (float)info.Height / sKBitmap.Height);
        float x = (info.Width - scale * scrollScale * sKBitmap.Width) / 2;
        float y = (info.Height - scale * scrollScale * sKBitmap.Height) / 2;
        float x2 = x + scale * scrollScale * sKBitmap.Width;
        float y2 = y + scale * scrollScale * sKBitmap.Height;
        bitmapRect = new SKRect(x, y, x2, y2);

        // panning
        float panX = panRect.Right - panRect.Left;
        float panY = panRect.Bottom - panRect.Top;
        panOffset.x += panX / scrollScale;
        panOffset.y += panY / scrollScale;

        panRect.Left = panRect.Right;
        panRect.Top = panRect.Bottom;

        bitmapRect.Left += panOffset.x * scrollScale;
        bitmapRect.Top += panOffset.y * scrollScale;
        bitmapRect.Right += panOffset.x * scrollScale;
        bitmapRect.Bottom += panOffset.y * scrollScale;

        //}
        scrollScaleChanged = false;

        // tilting - rotate bitmap and draw level lines
        //if(tiltAngle != 0)
        if(tilting)
        {
            canvas.RotateDegrees(tiltAngle, infoMiddleX, infoMiddleY);
            canvas.DrawBitmap(sKBitmap, bitmapRect, new SKPaint() { IsAntialias = true });
            canvas.RotateDegrees(-tiltAngle, infoMiddleX, infoMiddleY);
            //tiltAngle = 0;

            SKPaint directionPaint = new SKPaint()
            {
                Style = SKPaintStyle.Stroke,
                StrokeWidth = 1,
                Color = SKColors.White
            };
            canvas.DrawLine(0, infoMiddleY, info.Width, infoMiddleY, directionPaint);
            canvas.DrawLine(infoMiddleX, 0, infoMiddleX, info.Height, directionPaint);
        }
        else
        {
            canvas.DrawBitmap(sKBitmap, bitmapRect);
        }

        // draw cross in the middle
        float crossLength = 10;
        SKPaint crossPaint = new SKPaint()
            {
                Style = SKPaintStyle.Stroke,
                StrokeWidth = 2,
                Color = SKColors.White
            };
        canvas.DrawLine(infoMiddleX - crossLength, infoMiddleY, infoMiddleX + crossLength, infoMiddleY, crossPaint);
        canvas.DrawLine(infoMiddleX, infoMiddleY  - crossLength, infoMiddleX, infoMiddleY  + crossLength, crossPaint);


        // create unselected path, add bitmapRect
        SKPath unselected = new SKPath();
        unselected.AddRect(bitmapRect);
        // tilt unselected path (bitmapRect)
        if(tilting)
        {
            // tilt unselected (bitmapRect)
            SKMatrix result = SKMatrix.CreateRotationDegrees(tiltAngle, infoMiddleX, infoMiddleY);
            unselected.Transform(result);
            // calculate selectRect
            if (makeSelectRect)
            {
                tiltedBitmapCorners = unselected.Points;
                tiltedBitmapRect = unselected.Bounds;
                GenerateSelectRect(new SKPoint(infoMiddleX, infoMiddleY));
                makeSelectRect = false;
            }
        }

        // adjust and draw selectRect, add selectRect to unselected (path)
        if (selectRect != SKRect.Empty)
        {
            if(!isDown)
                AdjustSelection();
            Console.WriteLine($"{selectRect.Left}, {selectRect.Top}");

            SKColor selectionColor = SKColors.White;
            SKPaint paint = new SKPaint()
            {
                Style = SKPaintStyle.Stroke,
                StrokeWidth = 3,
                PathEffect = SKPathEffect.CreateDash(new float[] { 4, 4 }, 0),
                Color = selectionColor
            };
            canvas.DrawRect(selectRect, paint);

            SKPaint circlePaint = new SKPaint()
            {
                Style = SKPaintStyle.Fill,
                IsAntialias = true,
                Color = selectionColor
            };

            // add selectRect to unselected (path)
            unselected.AddRect(selectRect);
            unselected.FillType = SKPathFillType.EvenOdd;
            SKPaint unselectedPaint = new SKPaint
            {
                Style = SKPaintStyle.Fill,
                Color = SKColors.Black.WithAlpha((byte)(0.5 * 255)),

            };
            canvas.DrawPath(unselected, unselectedPaint);

            // draw corners of selectRect
            canvas.DrawCircle(selectRect.Left, selectRect.Top, selectCornerRadius, circlePaint);
            canvas.DrawCircle(selectRect.Right, selectRect.Bottom, selectCornerRadius, circlePaint);
            //canvas.DrawCircle(selectRect.Left, selectRect.Bottom, selectCornerRadius, circlePaint);
            //canvas.DrawCircle(selectRect.Right, selectRect.Top, selectCornerRadius, circlePaint);
        }
        Console.WriteLine("painted");
    }

    // rotating selectRect doesnt work properly for both AdjustSelection()s
    // (rotating multiple times)
    // using skiasharp matrix transform
    private void AdjustSelection()
    {
        //
        if(rotateSelect)
        {
            float viewtoBitmapRatio = bitmapRect.Width / (float)sKBitmap.Width;
            SKMatrix scaleR = SKMatrix.CreateScale(viewtoBitmapRatio, viewtoBitmapRatio);
            SKMatrix resultR = SKMatrix.CreateIdentity();
            SKMatrix.PreConcat(ref resultR, scaleR);
            selectRect = resultR.MapRect(selectRect);

            selectOffset.x = selectRect.Left;
            selectOffset.y = selectRect.Top;

            SKMatrix translateR = SKMatrix.CreateTranslation(bitmapRect.Left, bitmapRect.Top);
            
            resultR = SKMatrix.CreateIdentity();
            SKMatrix.PreConcat(ref resultR, translateR);
            selectRect = resultR.MapRect(selectRect);

            SetSelectOriginal();
            rotateSelect = false;
        }
        //

        // selectRectOriginal jest dla scrollscale = 1
        // skalowanie selectRect
        // powinno byc zastosowane na selectRectOriginal
        SKMatrix scale = SKMatrix.CreateScale(scrollScale, scrollScale);
        SKMatrix result = SKMatrix.CreateIdentity();
        SKMatrix.PreConcat(ref result, scale);
        selectRect = result.MapRect(selectRectOriginal);

        // potrzebne do przeniesienia selectRect do poczatku bitmapRect
        // tu pewnie problem ze zmianą selekcji przy zaznaczeniu SE -> NW
        SKMatrix translate1 = SKMatrix.CreateTranslation(-selectRect.Left, -selectRect.Top);

        // przeniesienie selectRect do poczatku bitmapRect
        SKMatrix translate2 = SKMatrix.CreateTranslation(bitmapRect.Left, bitmapRect.Top);

        // skalowanie offsetu selectRect wzgledem poczatku bitmapRect
        selectOffset.x = selectOffsetOriginal.x * scrollScale;
        selectOffset.y = selectOffsetOriginal.y * scrollScale;

        // przeniesienie selectRect o selectOffset
        SKMatrix translate3 = SKMatrix.CreateTranslation(selectOffset.x, selectOffset.y);

        // macierz transformacji + transfromacja selectRect
        result = SKMatrix.CreateIdentity();
        SKMatrix.PreConcat(ref result, translate3);
        SKMatrix.PreConcat(ref result, translate2);
        SKMatrix.PreConcat(ref result, translate1);
        selectRect = result.MapRect(selectRect);
    }

    // manual manipulation
    private void AdjustSelection2()
    {
        //
        if(rotateSelect)
        {
            float viewtoBitmapRatio = bitmapRect.Width / (float)sKBitmap.Width;
            SKMatrix result = SKMatrix.CreateIdentity();
            SKMatrix scale = SKMatrix.CreateScale(viewtoBitmapRatio, viewtoBitmapRatio);
            //result.PreConcat(scale);
            SKMatrix.PreConcat(ref result, scale);
            ShowSKMatrix(result, $"scale {viewtoBitmapRatio}");
            selectRect = result.MapRect(selectRect);

            selectOffset.x = selectRect.Left;
            selectOffset.y = selectRect.Top;

            result = SKMatrix.CreateIdentity();
            SKMatrix translate = SKMatrix.CreateTranslation(bitmapRect.Left, bitmapRect.Top);
            //result.PreConcat(translate);
            SKMatrix.PreConcat(ref result, translate);
            ShowSKMatrix(result, $"translate {bitmapRect.Left} {bitmapRect.Top}");
            selectRect = result.MapRect(selectRect);

            SetSelectOriginal();
            rotateSelect = false;
        }
        //

        // selectRectOriginal jest dla scrollscale = 1
        // skalowanie selectRect
        selectRect.Left = selectRectOriginal.Left * scrollScale;
        selectRect.Top = selectRectOriginal.Top * scrollScale;
        selectRect.Right = selectRectOriginal.Right * scrollScale;
        selectRect.Bottom = selectRectOriginal.Bottom * scrollScale;
        
        // potrzebne do przeniesienia selectRect do poczatku bitmapRect
        // tu pewnie problem ze zmianą selekcji przy zaznaczeniu SE -> NW
        selectRect.Right -= selectRect.Left;
        selectRect.Bottom -= selectRect.Top;
        selectRect.Left = 0;
        selectRect.Top = 0;
        
        // przeniesienie selectRect do poczatku bitmapRect
        selectRect.Left += bitmapRect.Left;
        selectRect.Top += bitmapRect.Top;
        selectRect.Right += bitmapRect.Left;
        selectRect.Bottom += bitmapRect.Top;
        
        // skalowanie offsetu selectRect wzgledem poczatku bitmapRect
        selectOffset.x = selectOffsetOriginal.x * scrollScale;
        selectOffset.y = selectOffsetOriginal.y * scrollScale;

        // przeniesienie selectRect o selectOffset
        selectRect.Left += selectOffset.x;
        selectRect.Top += selectOffset.y;
        selectRect.Right += selectOffset.x;
        selectRect.Bottom += selectOffset.y;
    }

    public bool PointInRectangle(SKPoint M, SKPoint[] r)
    {
        //var A = new SKPoint(r.Left, r.Top);
        //var B = new SKPoint(r.Right, r.Top);
        //var C = new SKPoint(r.Left, r.Bottom);

        var A = r[0];
        var B = r[1];
        var C = r[2];

        var AB = MakeVector(A, B);
        var AM = MakeVector(A, M);
        var BC = MakeVector(B, C);
        var BM = MakeVector(B, M);

        var dotABAM = DotProduct(AB, AM);
        var dotABAB = DotProduct(AB, AB);
        var dotBCBM = DotProduct(BC, BM);
        var dotBCBC = DotProduct(BC, BC);

        return 0 <= dotABAM && dotABAM <= dotABAB && 0 <= dotBCBM && dotBCBM <= dotBCBC;
    }

    public SKPoint MakeVector(SKPoint p1, SKPoint p2)
    {
        return new SKPoint(p2.X - p1.X, p2.Y - p1.Y);
    }

    public float DotProduct(SKPoint u, SKPoint v)
    {
        return u.X * v.X + u.Y * v.Y;
    }

    public void ResetTilt()
    {
        tiltAngle = 0;
        tilting = false;
        skiaView.Invalidate();
    }

    public void TiltImage()
    {
        //sKBitmap = TiltBitmap(degrees);
        //AddBitmap(sKBitmap);
        //ResetPanOffset();
        //ResetScale();

        //tiltAngle += degrees;
        //tiltAngle = degrees;
        tilting = true;
        makeSelectRect = true;
        ResetPanOffset();
        skiaView.Invalidate();
    }

    // to be added
    public SKBitmap TiltBitmap2(float degrees)
    {
        SKBitmap rotatedBitmap = new SKBitmap(sKBitmap.Height, sKBitmap.Width);
        using (SKCanvas canvas = new SKCanvas(rotatedBitmap))
        {
            canvas.Clear();
            canvas.Translate(sKBitmap.Height, 0);
            canvas.RotateDegrees(degrees);
            canvas.DrawBitmap(sKBitmap, new SKPoint(0,0));
        }

        return rotatedBitmap;
    }

    public void ShowSKMatrix(SKMatrix result, string title)
    {
        string str = $"{title}: ";
        foreach (var item in result.Values)
        {
            str += $"{item}, ";
        }
        //Console.WriteLine(str);
    }

    public void FlipImage(bool isHorizontal)
    {
        sKBitmap = FlipBitmap(isHorizontal);
        AddBitmap(sKBitmap);
        if(selectRect != SKRect.Empty)
            FlipRect2(isHorizontal);
        ResetPanOffset();
        //ResetScale();

        skiaView.Invalidate();
    }

    public SKBitmap FlipBitmap(bool isHorizontal)
    {
        SKBitmap flippedBitmap = new SKBitmap(sKBitmap.Width, sKBitmap.Height);

        using (SKCanvas canvas = new SKCanvas(flippedBitmap))
        {
            canvas.Clear();
            if (isHorizontal)
            { 
                canvas.Translate(sKBitmap.Width, 0);
                canvas.Scale(-1, 1);
            }
            else
            { 
                canvas.Translate(0, sKBitmap.Height); 
                canvas.Scale(1, -1);
            }
            canvas.DrawBitmap(sKBitmap, new SKPoint(0,0));
        }

        return flippedBitmap;
    }

    public void FlipRect2(bool isHorizontal)
    {
        selectRect.Left -= bitmapRect.Left;
        selectRect.Top -= bitmapRect.Top;
        selectRect.Right -= bitmapRect.Left;
        selectRect.Bottom -= bitmapRect.Top;

        var result = SKMatrix.CreateIdentity();
        SKMatrix translate, scale;
        if (isHorizontal)
        { 
            translate = SKMatrix.CreateTranslation(bitmapRect.Width, 0);
            scale = SKMatrix.CreateScale(-1, 1);
        }
        else
        { 
            translate = SKMatrix.CreateTranslation(0, bitmapRect.Height);
            scale = SKMatrix.CreateScale(1, -1);
        }
        SKMatrix.PreConcat(ref result, translate);
        SKMatrix.PreConcat(ref result, scale);
        selectRect = result.MapRect(selectRect);

        selectRect.Left += bitmapRect.Left;
        selectRect.Top += bitmapRect.Top;
        selectRect.Right += bitmapRect.Left;
        selectRect.Bottom += bitmapRect.Top;

        SetUpNewSelectRect();
    }

    public void RotateImage()
    {
        if(selectRect != SKRect.Empty)
            RotateRect3();
        sKBitmap = RotateBitmap();
        AddBitmap(sKBitmap);
        ResetPanOffset();
        //ResetScale();

        skiaView.Invalidate();
    }

    public SKBitmap RotateBitmap()
    {
        SKBitmap rotatedBitmap = new SKBitmap(sKBitmap.Height, sKBitmap.Width);
        using (SKCanvas canvas = new SKCanvas(rotatedBitmap))
        {
            canvas.Clear();
            canvas.Translate(sKBitmap.Height, 0);
            canvas.RotateDegrees(90);
            canvas.DrawBitmap(sKBitmap, new SKPoint(0,0));
        }

        return rotatedBitmap;
    }

    public void RotateRect3()
    {
        SKMatrix result = SKMatrix.CreateIdentity();
        //SKMatrix translate = SKMatrix.CreateTranslation(-selectOffset.x, -selectOffset.y);
        SKMatrix translate = SKMatrix.CreateTranslation(-bitmapRect.Left, -bitmapRect.Top);
        //result.PreConcat(translate);
        SKMatrix.PreConcat(ref result, translate);
        ShowSKMatrix(result, $"translate {-bitmapRect.Left}, {-bitmapRect.Top}");
        selectRect = result.MapRect(selectRect);

        float bitmaptoViewRatio = (float)sKBitmap.Width / bitmapRect.Width;
        result = SKMatrix.CreateIdentity();
        SKMatrix scale = SKMatrix.CreateScale(bitmaptoViewRatio, bitmaptoViewRatio);
        //result.PreConcat(scale);
        SKMatrix.PreConcat(ref result, scale);
        ShowSKMatrix(result, $"scale {bitmaptoViewRatio}");
        selectRect = result.MapRect(selectRect);

        result = SKMatrix.CreateRotationDegrees(90);
        ShowSKMatrix(result, "rotate 90");
        selectRect = result.MapRect(selectRect);

        result = SKMatrix.CreateIdentity();
        translate = SKMatrix.CreateTranslation(sKBitmap.Height, 0);
        //result.PreConcat(translate);
        SKMatrix.PreConcat(ref result, translate);
        ShowSKMatrix(result, $"translate {sKBitmap.Height} {0}");
        selectRect = result.MapRect(selectRect);

        //result = SKMatrix.CreateIdentity();
        //scale = SKMatrix.CreateScale(1/bitmaptoViewRatio, 1/bitmaptoViewRatio);
        //result.PreConcat(scale);
        //selectRect = result.MapRect(selectRect);

        OrderSelectRect();
        //
        rotateSelect = true;
    //
    }

    [JSInvokable]
    public void OnKeyPressedJS(bool eCtrlKey, bool eShiftKey, string eCode)
    {
        //Console.WriteLine($"c#: e.CtrlKey: {eCtrlKey}, e.ShiftKey: {eShiftKey}, e.Key: {eCode}");
        if(eCode =="KeyZ")
        {
            if(eCtrlKey)
            {
                if(eShiftKey)
                {
                    currentIndex++;
                }
                else
                {
                    currentIndex--;
                }
                currentIndex = Math.Max(0, currentIndex);
                currentIndex = Math.Min(Math.Max(0, lastBitmaps.Count - 1), currentIndex);

                sKBitmap = lastBitmaps[currentIndex];
                //Console.WriteLine($"currentIndex: {currentIndex}");
                skiaView.Invalidate();
            }
        }
    }

    private void AddBitmap(SKBitmap bitmap)
    {
        //int imax = 5;
        if(currentIndex < lastBitmaps.Count - 1)
        {
            lastBitmaps.RemoveRange(currentIndex + 1, lastBitmaps.Count - currentIndex - 1);
            lastBitmaps.Add(bitmap);
            currentIndex++;
        }
        else
        {
            if (lastBitmaps.Count < imax)
            {
                lastBitmaps.Add(bitmap);
                currentIndex++;
            }
            else
            {
                lastBitmaps = lastBitmaps.GetRange(1, lastBitmaps.Count - 1);
                lastBitmaps.Add(bitmap);
            }
        }
    }

    private void OrderSelectRect()
    {
        if (selectRect.Left > selectRect.Right)
        {
            float tLeft = selectRect.Left;
            selectRect.Left = selectRect.Right;
            selectRect.Right = tLeft;
        }

        if (selectRect.Top > selectRect.Bottom)
        {
            float tTop = selectRect.Top;
            selectRect.Top = selectRect.Bottom;
            selectRect.Bottom = tTop;
        }
    }

    private void CropImage()
    {
        if (selectRect != SKRect.Empty)
        {
            float bitmapToViewRatio = (float)sKBitmap.Width / bitmapRect.Width;

            //(float x, float y) scaledOffset;
            //scaledOffset.x = selectOffset.x * viewToBitmapRatio;
            //scaledOffset.y = selectOffset.y * viewToBitmapRatio;

            // order selection start and end
            OrderSelectRect();

            // odjac poczatek bitmapy od selectRect
            selectRect.Left -= bitmapRect.Left;
            selectRect.Top -= bitmapRect.Top;
            selectRect.Right -= bitmapRect.Left;
            selectRect.Bottom -= bitmapRect.Top;

            SKRect cropRect = SKRect.Empty;
            cropRect.Left = selectRect.Left * bitmapToViewRatio;
            cropRect.Top = selectRect.Top * bitmapToViewRatio;
            cropRect.Right = selectRect.Right * bitmapToViewRatio;
            cropRect.Bottom = selectRect.Bottom * bitmapToViewRatio;

            SKRect dest = new SKRect(0, 0, cropRect.Width, cropRect.Height);

            SKBitmap croppedBitmap = new SKBitmap((int)cropRect.Width, (int)cropRect.Height);

            //Console.WriteLine($"viewToBitmapRatio: {viewToBitmapRatio}");
            //Console.WriteLine($"sKBitmap ratio: {(float)sKBitmap.Width / sKBitmap.Height}");
            //Console.WriteLine($"bitmapRect ratio: {bitmapRect.Width / bitmapRect.Height}");
            //Console.WriteLine($"selectRect: {selectRect.Width}, {selectRect.Height}");
            //Console.WriteLine($"        : ({selectRect.Left}, {selectRect.Top})");
            //Console.WriteLine($"        : ({selectRect.Right}, {selectRect.Bottom})");

            //Console.WriteLine($"sKBitmap: {sKBitmap.Width}, {sKBitmap.Height}");
            //Console.WriteLine($"cropRect: {cropRect.Width}, {cropRect.Height}");
            //Console.WriteLine($"        : ({cropRect.Left}, {cropRect.Top})");
            //Console.WriteLine($"        : ({cropRect.Right}, {cropRect.Bottom})");
            //Console.WriteLine($"croppedBitmap: {croppedBitmap.Width}, {croppedBitmap.Height}");

            using (SKCanvas canvas = new SKCanvas(croppedBitmap))
            {
                canvas.DrawBitmap(sKBitmap, cropRect, dest);
            }

            //lastBitmaps.Add(sKBitmap);
            sKBitmap = croppedBitmap;
            AddBitmap(sKBitmap);

            //scrollScale = 1;
            selectRect = SKRect.Empty;

            ResetPanOffset();

            skiaView.Invalidate();
        }
        else
            Console.WriteLine("No selection error message");
    }

    private void ResetPanOffset()
    {
        panOffset = (0, 0);
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void ResetScale()
    {
        scrollScale = 1;
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void OnMouseWheel(WheelEventArgs e)
    {
        if(e.DeltaY > 0)
        {
            if (scrollScale < 2)
            {
                scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
            }
        }
        else
        {
            if (scrollScale > 0.2)
            {
                scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
            }
        }
        //Console.WriteLine($"OnMouseWheel: {e.DeltaY}, {scrollScale}");
        scrollScaleChanged = true;
        skiaView.Invalidate();
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        //Console.WriteLine($"{e.Button}");
        // middle mouse button
        if (e.Button == 1 && !tilting)
        {
            isMiddle = true;
            panRect.Left = (float)e.OffsetX;
            panRect.Top = (float)e.OffsetY;
        }
        else if(e.Button == 0)
        {
            clickTime.Start();
            //Console.WriteLine("timer start");
            isDown = true;
            (float scaledOffsetX, float scaledOffsetY) = ScaleOffsets((float)e.OffsetX, (float)e.OffsetY);
            //Console.WriteLine($"OnMouseDown: scaledOffsetX: {scaledOffsetX}, scaledOffsetY: {scaledOffsetY}");
            distance = Distance(selectRect.Right, selectRect.Bottom,
                                scaledOffsetX, scaledOffsetY);
            if (distance > selectCornerRadius)
            {
                distance = Distance(selectRect.Left, selectRect.Top,
                                    scaledOffsetX, scaledOffsetY);
                if (distance > selectCornerRadius)
                {
                    SetSelectionStart(scaledOffsetX, scaledOffsetY);
                    SetSelectionOffset();
                }
                else
                {
                    ReverseSelection();
                    SetSelectionOffset();
                }
            }
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        (float scaledOffsetX, float scaledOffsetY) = ScaleOffsets((float)e.OffsetX, (float)e.OffsetY);
        if (isDown)
        {
            SetSelectionEnd(scaledOffsetX, scaledOffsetY);
            //Console.WriteLine($"OnMouseMove: scaledOffsetX: {scaledOffsetX}, scaledOffsetY: {scaledOffsetY}");
            SetSelectOriginal();
            skiaView.Invalidate();
        }

        if(isMiddle && !tilting)
        {
            panRect.Right = (float)e.OffsetX;
            panRect.Bottom = (float)e.OffsetY;
            skiaView.Invalidate();
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        isDown = false;
        isMiddle = false;
        //Console.WriteLine($"OnMouseUp: e.OffsetX: {e.OffsetX * windowDPR}, e.OffsetY: {e.OffsetY * windowDPR}");
    }

    private void OnMouseOut(MouseEventArgs e)
    {
        clickTime.Stop();
        //Console.WriteLine("timer stop");
        isDown = false;
        isMiddle = false;
        //Console.WriteLine("Out:");
    }

    // timer between down-up, short click resets rect
    private void OnClick(MouseEventArgs e)
    {
        clickTime.Stop();
        //Console.WriteLine("timer stop");
        //Console.WriteLine("Click");
        if (isClick)
        {
            selectRect = SKRect.Empty;
            skiaView.Invalidate();
        }
        isClick = true;
    }

    private float Distance( float x1, float y1, float x2, float y2)
    {
        return (float)Math.Sqrt(Math.Pow(x1-x2, 2) + Math.Pow(y1-y2, 2));
    }

    private (float scaledOffsetX, float scaledOffsetY) ScaleOffsets(float eOffsetX, float eOffsetY)
    {
        return ((float)eOffsetX * windowDPR, (float)eOffsetY * windowDPR);
    }

    private void ReverseSelection()
    {
        float left = selectRect.Left;
        float top = selectRect.Top;

        selectRect.Left = selectRect.Right;
        selectRect.Right = left;
        selectRect.Top = selectRect.Bottom;
        selectRect.Bottom = top;
    }

    private void SetSelectionOffset()
    {
        selectOffset.x = selectRect.Left - bitmapRect.Left;
        selectOffset.y = selectRect.Top - bitmapRect.Top;
        //Console.WriteLine($"b:({bitmapRect.Left}, {bitmapRect.Top})\n"+
                                //$"s:({selectRect.Left}, {selectRect.Top})\n"+ 
                                //$"o: ({selectOffset.x}, {selectOffset.y}))");
    }

    private void SetSelectionStart(double offsetX, double offsetY)
    {
        if(tilting)
        {
            if(PointInRectangle(new SKPoint((float)offsetX, (float)offsetY), tiltedBitmapCorners))
            {
                selectRect.Left = (float)offsetX;
                selectRect.Top = (float)offsetY;
                Console.WriteLine("PointInRectangle: true");
            }
            else{Console.WriteLine("PointInRectangle: false");}
        }
        else
        {
            selectRect.Left = (float)Math.Max(bitmapRect.Left, offsetX);
            selectRect.Top = (float)Math.Max(bitmapRect.Top, offsetY);

            selectRect.Left = (float)Math.Min(bitmapRect.Right, selectRect.Left);
            selectRect.Top = (float)Math.Min(bitmapRect.Bottom, selectRect.Top);
        }
    }

    private void SetSelectionEnd(double offsetX, double offsetY)
    {
        if (tilting)
        {
            if (selectRect != SKRect.Empty && PointInRectangle(new SKPoint((float)offsetX, (float)offsetY), tiltedBitmapCorners)
                && PointInRectangle(new SKPoint(selectRect.Left, (float)offsetY), tiltedBitmapCorners)
                && PointInRectangle(new SKPoint((float)offsetX, selectRect.Top), tiltedBitmapCorners))
            {
                selectRect.Right = (float)offsetX;
                selectRect.Bottom = (float)offsetY;
                Console.WriteLine("PointInRectangle: true");
            }
            else { Console.WriteLine("PointInRectangle: false"); }
        }
        else
        {
            selectRect.Right = (float)Math.Min(bitmapRect.Right, offsetX);
            selectRect.Bottom = (float)Math.Min(bitmapRect.Bottom, offsetY);

            selectRect.Right = (float)Math.Max(bitmapRect.Left, selectRect.Right);
            selectRect.Bottom = (float)Math.Max(bitmapRect.Top, selectRect.Bottom);
        }
    }

    private void SetSelectOriginal()
    {
        selectRectOriginal.Left = selectRect.Left / scrollScale;
        selectRectOriginal.Top = selectRect.Top / scrollScale;
        selectRectOriginal.Right = selectRect.Right / scrollScale;
        selectRectOriginal.Bottom = selectRect.Bottom / scrollScale;

        selectOffsetOriginal.x = selectOffset.x / scrollScale;
        selectOffsetOriginal.y = selectOffset.y / scrollScale;
    }

    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }

    [JSInvokable]
    public void SetWindowDPR(float pr)
    {
        windowDPR = pr;
        //Console.WriteLine("SetWindowDPR");
    }

    protected override async Task OnInitializedAsync()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
        //windowDPR = await JS.InvokeAsync<float>("windowDevicePixelRatio");
        await JS.InvokeVoidAsync("WindowDPRHelper.callupdatePixelRatio", dotNetHelper);

        //windowDPR = await JS.InvokeAsync<float>("windowDevicePixelRatio");
        //windowDPR = await JS.InvokeAsync<float>("callUpdatePixelRatio");

        //Console.WriteLine($"window.devicePixelRatio: {windowDPR}");
        //ImageName = SService.ImageName;
        clickTime.Elapsed += (sender, e) => {isClick = false;};
        var openDbResult = await IndexedDbContext.OpenIndexedDb();
        ImageName = await LSManager.GetImageName();
        if(ImageName != null)
        {
            //Console.WriteLine($"ImageName: {ImageName}");
            imageResized = await IDbManager.FetchImageResized(ImageName);
            if(imageResized != null)
            {
                //sKBitmap = SKBitmap.Decode(imageResized.ImageArray);

                //testSrc = await ImageProc.GetImageURL(imageResized.ImageArray);
            }

            var imageData = await IDbManager.FetchImageData(ImageName);
            if(imageData != null)
            {
                sKBitmap = SKBitmap.Decode(imageData.ImageArray);
                AddBitmap(sKBitmap);

                //int w = 1000;
                //CanvasAttributes = new Dictionary<string, object> 
                //{{ "width", $"{w}" },
                //{ "height", $"{(int)(((float)w/sKBitmap.Width)*sKBitmap.Height)}" }};

                //CanvasAttributes = new Dictionary<string, object> 
                //{{ "width", $"{sKBitmap.Width}" },
                //{ "height", $"{sKBitmap.Height}" }};

                testSrc2 = await ImageProc.GetImageURL(imageData.ImageArray);
            }
        }

        //testSrc = await TestStuff();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //await SetupBECanvas();
            await JS.InvokeVoidAsync("attachHandlers");
        }
    }

    //private void OnMouseWheel(WheelEventArgs e)
    //{
    //    // scroll up / zoom in
    //    //if(e.DeltaY > 0)
    //    //{
    //    //    if (scrollScale < 10)
    //    //    {
    //    //        if (scrollScale < 1)
    //    //            scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
    //    //        else
    //    //            scrollScale = (float)Math.Round(scrollScale + 1, 0);
    //    //    }
    //    //}
    //    //else
    //    //{
    //    //    if (scrollScale > 0.2)
    //    //    {
    //    //        if (scrollScale <= 1)
    //    //            scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
    //    //        else
    //    //            scrollScale = (float)Math.Round(scrollScale - 1, 0);
    //    //    }
    //    //}

    //    if(e.DeltaY > 0)
    //    {
    //        if (scrollScale < 2)
    //        {
    //            scrollScale = (float)Math.Round(scrollScale + 0.1f, 1);
    //        }
    //    }
    //    else
    //    {
    //        if (scrollScale > 0.2)
    //        {
    //            scrollScale = (float)Math.Round(scrollScale - 0.1f, 1);
    //        }
    //    }
    //    Console.WriteLine($"{e.DeltaY}, {scrollScale}");
    //    skiaView.Invalidate();
    //}

    //public async Task<string> TestStuff()
    //{
    //    var testImage = await IDbManager.FetchImageResized(ImageName);
    //    var imageSrc = await ImageProc.GetImageURL(testImage.ImageArray);

    //    return imageSrc;
    //}

    //private Canvas2DContext _context;
    //protected BECanvasComponent _canvasReference;
    //protected ElementReference imgReference;

    //public async Task SetupBECanvas()
    //{
    //    if(_canvasReference != null)
    //        _context = await _canvasReference.CreateCanvas2DAsync();
    //    //await this._context.SetFillStyleAsync("green");

    //    //await this._context.FillRectAsync(10, 100, 100, 100);

    //    //await this._context.SetFontAsync("48px serif");
    //    //await this._context.StrokeTextAsync("Hello Blazor!!!", 10, 100);

    //    if(_context != null)
    //        await _context.DrawImageAsync(imgReference,0,0);

    //        StateHasChanged();
    //}

}