@using Radzen.Blazor
@inject StateService SService
@inject ImageProcessing ImageProc

<p class="fs-6 fw-bold m-2">Histogram</p>
<div class="container my-2">
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isRed" id="flexCheckChecked6"
            @onchange="() => ToggleColor(SKColorChannel.R)">
        <label class="form-check-label" for="flexCheckChecked6">Red</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isGreen" id="flexCheckChecked5"
            @onchange="() => ToggleColor(SKColorChannel.G)">
        <label class="form-check-label" for="flexCheckChecked5">Green</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isBlue" id="flexCheckChecked4"
            @onchange="() => ToggleColor(SKColorChannel.B)">
        <label class="form-check-label" for="flexCheckChecked4">Blue</label>
    </div>
</div>

@if(dataIsSet)
{
    <div class="w-100 border border-success ps-2 my-2">
        @if (isRed)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramR" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorRed" Fill="@colorRed">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of red: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isGreen)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramG" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorGreen" Fill="@colorGreen">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of green: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isBlue)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramB" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorBlue" Fill="@colorBlue">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of blue: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
    </div>
}

@code {

    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
    }

    HistogramItem[] histogramR;
    HistogramItem[] histogramG;
    HistogramItem[] histogramB;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";
    public bool isRed = false;
    public bool isGreen = false;
    public bool isBlue = false;

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }

        //step = array.Max() / 4;

        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
                //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
            };
        }

        return resultH;
    }

    private async Task RedrawHistogram()
    {
        if (isRed || isGreen || isBlue)
        {
            await SetData();
            StateHasChanged();
        }
    }

    private async Task SetData()
    {
        int maxR = 1;
        int maxG = 1;
        int maxB = 1;
        SKColor[] pixels = SService.bitmap.Pixels;
        if (isRed)
        {
            byte[] pixelsR = pixels.Select(x => x.Red).ToArray();
            histogramR = GetHistogram(pixelsR);
            maxR = (int)Math.Ceiling(histogramR.Max(x => x.Count) / 4d);
        }
        if (isGreen)
        {
            byte[] pixelsG = pixels.Select(x => x.Green).ToArray();
            histogramG = GetHistogram(pixelsG);
            maxG = (int)Math.Ceiling(histogramG.Max(x => x.Count) / 4d);
        }
        if (isBlue)
        {
            byte[] pixelsB = pixels.Select(x => x.Blue).ToArray();
            histogramB = GetHistogram(pixelsB);
            maxB = (int)Math.Ceiling(histogramB.Max(x => x.Count) / 4d);
        }
        pixelsLength = pixels.Length;
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        step = new List<int>{ maxR, maxG, maxB }.Max();
        dataIsSet = true;
    }

    public async Task ToggleColor(SKColorChannel channel)
    {
        switch(channel)
        {
            case SKColorChannel.R:
                isRed = ! isRed;
                break;
            case SKColorChannel.G:
                isGreen = ! isGreen;
                break;
            case SKColorChannel.B:
                isBlue = ! isBlue;
                break;
        }
        await RedrawHistogram();
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

@code{
    /*
     * @using Radzen.Blazor
@inject StateService SService
@inject ImageProcessing ImageProc

@if(dataIsSet)
{
    <p class="fs-6 fw-bold m-2">Histogram</p>
    <div class="input-group m-2 w-75">
        <span class="input-group-text">Channel:</span>
        <select @onchange="OnChannelChosen" class="form-select">
            @*<option value="null" disabled selected>Choose filter</option>*@
            <option value=@SKColorChannel.R selected>Red</option>
            <option value=@SKColorChannel.G>Green</option>
            <option value=@SKColorChannel.B>Blue</option>
        </select>
    </div>

    <div class="w-100 border border-success ps-2 my-2">
	    <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
          <RadzenColumnSeries Data="@histogram" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
              Stroke="@barColor" Fill="@barColor">
              <TooltipTemplate Context="data">
                  <div>
                    Value: <strong>@data.Value</strong>
                    <br />
                    % of values: <strong>@Percent(data.Count)</strong>%
                  </div>
              </TooltipTemplate>
          </RadzenColumnSeries>
  
          <RadzenCategoryAxis Max="255" Step="50">
          </RadzenCategoryAxis>
  
          <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
              <RadzenGridLines Visible="true"/>
          </RadzenValueAxis>

          <RadzenLegend Visible="false" />
        </RadzenChart>
    </div>
}

@code {

    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
    }

    HistogramItem[] histogram;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }

        //step = array.Max() / 4;

        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
                //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
            };
        }

        return resultH;
    }

    private async Task RedrawHistogram()
    {
        await SetData();
        StateHasChanged();
    }

    private async Task SetData()
    {
        byte[] pixels;
        switch(channel)
        {
            case SKColorChannel.R:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
            case SKColorChannel.G:
                pixels = SService.bitmap.Pixels.Select(x => x.Green).ToArray();
                barColor = colorGreen;
                break;
            case SKColorChannel.B:
                pixels = SService.bitmap.Pixels.Select(x => x.Blue).ToArray();
                barColor = colorBlue;
                break;
            default:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
        }
        pixelsLength = pixels.Length;
        histogram = GetHistogram(pixels);
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        step = (int)Math.Ceiling(histogram.Max(x => x.Count) / 4d);
        dataIsSet = true;
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

     */
}
