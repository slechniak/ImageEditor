@using Radzen.Blazor
@using System.Diagnostics
@inject StateService SService
@inject ImageProcessing ImageProc

<p class="fs-6 fw-bold m-2">Histogram</p>
<div class="container my-2">
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isRed" id="flexCheckChecked6"
            @onchange="() => ToggleColor(SKColorChannel.R)">
        <label class="form-check-label" for="flexCheckChecked6">Red</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isGreen" id="flexCheckChecked5"
            @onchange="() => ToggleColor(SKColorChannel.G)">
        <label class="form-check-label" for="flexCheckChecked5">Green</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isBlue" id="flexCheckChecked4"
            @onchange="() => ToggleColor(SKColorChannel.B)">
        <label class="form-check-label" for="flexCheckChecked4">Blue</label>
    </div>
</div>

@if(dataIsSet)
{
    <div class="w-100 border border-success ps-2 my-2">
        @if (isRed)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style=@($"width: 100%; aspect-ratio: {aspectRatio}; height: auto;")>
                <RadzenColumnSeries Data="@histogramListR" CategoryProperty="Value"  StrokeWidth="@strokeWidth" ValueProperty="Count"
                Stroke="@colorRed" Fill="@colorRed">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of red: <strong>@Percent(data.Count)</strong>%
                            <br />
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Max="@maxR" Step="@stepR" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isGreen)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style=@($"width: 100%; aspect-ratio: {aspectRatio}; height: auto;")>
                <RadzenColumnSeries Data="@histogramListG" CategoryProperty="Value" StrokeWidth="@strokeWidth" ValueProperty="Count"
                Stroke="@colorGreen" Fill="@colorGreen">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of green: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Max="@maxG" Step="@stepG" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isBlue)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style=@($"width: 100%; aspect-ratio: {aspectRatio}; height: auto;")>
                <RadzenColumnSeries Data="@histogramListB" CategoryProperty="Value" StrokeWidth="@strokeWidth" ValueProperty="Count"
                Stroke="@colorBlue" Fill="@colorBlue">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of blue: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Max="@maxB" Step="@stepB" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
    </div>
}

@code {

    //class HistogramItem
    //{
    //    public byte Value { get; set; }
    //    public int Count { get; set; }
    //}
    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
        public int Max { get; set; }
    }

    HistogramItem[] histogramR;
    HistogramItem[] histogramG;
    HistogramItem[] histogramB;
    List<HistogramItem> histogramListR;
    List<HistogramItem> histogramListG;
    List<HistogramItem> histogramListB;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";
    double strokeWidth = 2;
    string aspectRatio = "4/3";
    public bool isRed = false;
    public bool isGreen = false;
    public bool isBlue = false;
    int maxR = 1;
    int maxG = 1;
    int maxB = 1;
    int stepR = 1;
    int stepG = 1;
    int stepB = 1;

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private async Task RedrawHistogram()
    {
        if (isRed || isGreen || isBlue)
        {
            await SetData();
            StateHasChanged();
        }
    }

    private async Task SetData()
    {
        Console.WriteLine("RedrawHistogram > SetData");

        maxR = 1;
        maxG = 1;
        maxB = 1;

        //Stopwatch stopwatch = new Stopwatch();
        //stopwatch.Start();

        SKColor[] pixels = SService.bitmap.Pixels;

        //stopwatch.Stop();
        //Console.WriteLine("pixels: {0} ms", stopwatch.ElapsedMilliseconds);
        if (isRed)
        {
            //stopwatch.Reset();
            //stopwatch.Start();

            //code
            var pixelsListR = pixels.Select(x => x.Red);

            //stopwatch.Stop();
            //Console.WriteLine("pixelsR2: {0} ms", stopwatch.ElapsedMilliseconds);

            //code
            histogramListR = GetHistogramItemList(pixelsListR);

            //stopwatch.Reset();
            //stopwatch.Start();

            //code
            //maxR = (int)Math.Ceiling(histogramListR.Max(x => x.Count) / 4d);
            maxR = histogramListR.Max(x => x.Count);

            //stopwatch.Stop();
            //Console.WriteLine("maxR2: {0} ms", stopwatch.ElapsedMilliseconds);
        }
        if (isGreen)
        {
            //byte[] pixelsG = pixels.Select(x => x.Green).ToArray();
            //histogramG = GetHistogram(pixelsG);
            //maxG = (int)Math.Ceiling(histogramG.Max(x => x.Count) / 4d);

            var pixelsListG = pixels.Select(x => x.Green);
            histogramListG = GetHistogramItemList(pixelsListG);
            //maxG = (int)Math.Ceiling(histogramListG.Max(x => x.Count) / 4d);
            maxG = histogramListG.Max(x => x.Count);
        }
        if (isBlue)
        {
            //byte[] pixelsB = pixels.Select(x => x.Blue).ToArray();
            //histogramB = GetHistogram(pixelsB);
            //maxB = (int)Math.Ceiling(histogramB.Max(x => x.Count) / 4d);

            var pixelsListB = pixels.Select(x => x.Blue);
            histogramListB = GetHistogramItemList(pixelsListB);
            //maxB = (int)Math.Ceiling(histogramListB.Max(x => x.Count) / 4d);
            maxB = histogramListB.Max(x => x.Count);
        }
        pixelsLength = pixels.Length;
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        //step = new List<int>{ maxR, maxG, maxB }.Max();
        double steps = 4;
        //step = (int)Math.Ceiling(new List<int>{ maxR, maxG, maxB }.Max() / steps);
        stepR = (int)Math.Round(maxR / steps);
        stepR = stepR > 0 ? stepR : 1;
        maxR = 4 * stepR + 1;

        stepG = (int)Math.Round(maxG / steps);
        stepG = stepG > 0 ? stepG : 1;
        maxG = 4 * stepG + 1;

        stepB = (int)Math.Round(maxB / steps);
        stepB = stepB > 0 ? stepB : 1;
        maxB = 4 * stepB + 1;

        dataIsSet = true;
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }
        stopwatch.Stop();
        Console.WriteLine("array: {0} ms", stopwatch.ElapsedMilliseconds);

        //step = array.Max() / 4;

        stopwatch.Reset();
        stopwatch.Start();
        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
                    {
                        Value = (byte)i,
                        Count = array[i]
                        //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
                    };
        }
        stopwatch.Stop();
        Console.WriteLine("resultH: {0} ms", stopwatch.ElapsedMilliseconds);

        return resultH;
    }

    private List<HistogramItem> GetHistogramItemList(IEnumerable<byte> pixels)
    {
        List<HistogramItem> resultH = new List<HistogramItem>();
        int[] array = ImageProc.GetHistogramArray(pixels);

        //stopwatch.Reset();
        //stopwatch.Start();

        for (int i = 0; i < array.Length; i++)
        {
            resultH.Add( new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
            });
        }

        //stopwatch.Stop();
        //Console.WriteLine("resultH2: {0} ms", stopwatch.ElapsedMilliseconds);

        return resultH;
    }

    public async Task ToggleColor(SKColorChannel channel)
    {
        switch(channel)
        {
            case SKColorChannel.R:
                isRed = ! isRed;
                break;
            case SKColorChannel.G:
                isGreen = ! isGreen;
                break;
            case SKColorChannel.B:
                isBlue = ! isBlue;
                break;
        }
        await RedrawHistogram();
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

@code{
    /*
     * @using Radzen.Blazor
@inject StateService SService
@inject ImageProcessing ImageProc

@if(dataIsSet)
{
    <p class="fs-6 fw-bold m-2">Histogram</p>
    <div class="input-group m-2 w-75">
        <span class="input-group-text">Channel:</span>
        <select @onchange="OnChannelChosen" class="form-select">
            @*<option value="null" disabled selected>Choose filter</option>*@
            <option value=@SKColorChannel.R selected>Red</option>
            <option value=@SKColorChannel.G>Green</option>
            <option value=@SKColorChannel.B>Blue</option>
        </select>
    </div>

    <div class="w-100 border border-success ps-2 my-2">
	    <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
          <RadzenColumnSeries Data="@histogram" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
              Stroke="@barColor" Fill="@barColor">
              <TooltipTemplate Context="data">
                  <div>
                    Value: <strong>@data.Value</strong>
                    <br />
                    % of values: <strong>@Percent(data.Count)</strong>%
                  </div>
              </TooltipTemplate>
          </RadzenColumnSeries>
  
          <RadzenCategoryAxis Max="255" Step="50">
          </RadzenCategoryAxis>
  
          <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
              <RadzenGridLines Visible="true"/>
          </RadzenValueAxis>

          <RadzenLegend Visible="false" />
        </RadzenChart>
    </div>
}

@code {

    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
    }

    HistogramItem[] histogram;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }

        //step = array.Max() / 4;

        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
                //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
            };
        }

        return resultH;
    }

    private async Task RedrawHistogram()
    {
        await SetData();
        StateHasChanged();
    }

    private async Task SetData()
    {
        byte[] pixels;
        switch(channel)
        {
            case SKColorChannel.R:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
            case SKColorChannel.G:
                pixels = SService.bitmap.Pixels.Select(x => x.Green).ToArray();
                barColor = colorGreen;
                break;
            case SKColorChannel.B:
                pixels = SService.bitmap.Pixels.Select(x => x.Blue).ToArray();
                barColor = colorBlue;
                break;
            default:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
        }
        pixelsLength = pixels.Length;
        histogram = GetHistogram(pixels);
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        step = (int)Math.Ceiling(histogram.Max(x => x.Count) / 4d);
        dataIsSet = true;
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

     */
}
