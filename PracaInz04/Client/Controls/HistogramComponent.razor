@using Radzen.Blazor
@using System.Diagnostics
@inject StateService SService
@inject ImageProcessing ImageProc

<p class="fs-6 fw-bold m-2">Histogram</p>
<div class="container my-2">
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isRed" id="flexCheckChecked6"
            @onchange="() => ToggleColor(SKColorChannel.R)">
        <label class="form-check-label" for="flexCheckChecked6">Red</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isGreen" id="flexCheckChecked5"
            @onchange="() => ToggleColor(SKColorChannel.G)">
        <label class="form-check-label" for="flexCheckChecked5">Green</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" value="@isBlue" id="flexCheckChecked4"
            @onchange="() => ToggleColor(SKColorChannel.B)">
        <label class="form-check-label" for="flexCheckChecked4">Blue</label>
    </div>
</div>

@if(dataIsSet)
{
    <div class="w-100 border border-success ps-2 my-2">
        @if (isRed)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramListR" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorRed" Fill="@colorRed">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of red: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isGreen)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramListG" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorGreen" Fill="@colorGreen">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of green: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
        @if (isBlue)
        {
            <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
                <RadzenColumnSeries Data="@histogramListB" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
                Stroke="@colorBlue" Fill="@colorBlue">
                    <TooltipTemplate Context="data">
                        <div>
                            Value: <strong>@data.Value</strong>
                            <br />
                            % of blue: <strong>@Percent(data.Count)</strong>%
                        </div>
                    </TooltipTemplate>
                </RadzenColumnSeries>

                <RadzenCategoryAxis Max="255" Step="50">
                </RadzenCategoryAxis>

                <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
                    <RadzenGridLines Visible="true"/>
                </RadzenValueAxis>

                <RadzenLegend Visible="false" />
            </RadzenChart>
        }
    </div>
}

@code {

    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
    }

    HistogramItem[] histogramR;
    HistogramItem[] histogramG;
    HistogramItem[] histogramB;
    List<HistogramItem> histogramListR;
    List<HistogramItem> histogramListG;
    List<HistogramItem> histogramListB;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";
    public bool isRed = false;
    public bool isGreen = false;
    public bool isBlue = false;

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private async Task RedrawHistogram()
    {
        if (isRed || isGreen || isBlue)
        {
            await SetData();
            StateHasChanged();
        }
    }

    private async Task SetData()
    {
        Console.WriteLine("RedrawHistogram > SetData");

        int maxR = 1;
        int maxG = 1;
        int maxB = 1;

        //Stopwatch stopwatch = new Stopwatch();
        //stopwatch.Start();

        SKColor[] pixels = SService.bitmap.Pixels;
        
        //stopwatch.Stop();
        //Console.WriteLine("pixels: {0} ms", stopwatch.ElapsedMilliseconds);
        if (isRed)
        {
            //stopwatch.Reset();
            //stopwatch.Start();
            
            //code
            var pixelsListR = pixels.Select(x => x.Red);
            
            //stopwatch.Stop();
            //Console.WriteLine("pixelsR2: {0} ms", stopwatch.ElapsedMilliseconds);
            
            //code
            histogramListR = GetHistogram2(pixelsListR);

            //stopwatch.Reset();
            //stopwatch.Start();

            //code
            maxR = (int)Math.Ceiling(histogramListR.Max(x => x.Count) / 4d);
            
            //stopwatch.Stop();
            //Console.WriteLine("maxR2: {0} ms", stopwatch.ElapsedMilliseconds);
        }
        if (isGreen)
        {
            //byte[] pixelsG = pixels.Select(x => x.Green).ToArray();
            //histogramG = GetHistogram(pixelsG);
            //maxG = (int)Math.Ceiling(histogramG.Max(x => x.Count) / 4d);

            var pixelsListG = pixels.Select(x => x.Green);
            histogramListG = GetHistogram2(pixelsListG);
            maxG = (int)Math.Ceiling(histogramListG.Max(x => x.Count) / 4d);
        }
        if (isBlue)
        {
            //byte[] pixelsB = pixels.Select(x => x.Blue).ToArray();
            //histogramB = GetHistogram(pixelsB);
            //maxB = (int)Math.Ceiling(histogramB.Max(x => x.Count) / 4d);

            var pixelsListB = pixels.Select(x => x.Blue);
            histogramListB = GetHistogram2(pixelsListB);
            maxB = (int)Math.Ceiling(histogramListB.Max(x => x.Count) / 4d);
        }
        pixelsLength = pixels.Length;
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        step = new List<int>{ maxR, maxG, maxB }.Max();
        dataIsSet = true;
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }
        stopwatch.Stop();
        Console.WriteLine("array: {0} ms", stopwatch.ElapsedMilliseconds);

        //step = array.Max() / 4;

        stopwatch.Reset();
        stopwatch.Start();
        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
                    {
                        Value = (byte)i,
                        Count = array[i]
                        //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
                    };
        }
        stopwatch.Stop();
        Console.WriteLine("resultH: {0} ms", stopwatch.ElapsedMilliseconds);

        return resultH;
    }

    private List<HistogramItem> GetHistogram2(IEnumerable<byte> pixels)
    {
        List<HistogramItem> resultH = new List<HistogramItem>();
        List<byte> pixelsList = pixels.ToList();

        //Stopwatch stopwatch = new Stopwatch();
        //stopwatch.Start();
        
        int[] array = new int[256];
        // fastest - around 110ms for cat01 500.jpg red
        foreach(var pixel in pixelsList)
        {
            array[pixel]++;
        }

        // fast - around 210ms for cat01 500.jpg red (IEnumerable<byte> pixels)
        //foreach(var pixel in pixels)
        //{
        //    array[pixel]++;
        //}

        // VERY slow, both
        //for (int i = 0; i < pixels.Count(); i++)
        //{
        //    Console.WriteLine(i);
        //    array[pixels.ElementAt(i)]++;
        //    array[pixelsList[i]]++;
        //}

        //stopwatch.Stop();
        //Console.WriteLine("array2: {0} ms", stopwatch.ElapsedMilliseconds);

        //step = array.Max() / 4;

        //stopwatch.Reset();
        //stopwatch.Start();

        for (int i = 0; i < array.Length; i++)
        {
            resultH.Add( new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
            });
        }

        //stopwatch.Stop();
        //Console.WriteLine("resultH2: {0} ms", stopwatch.ElapsedMilliseconds);

        return resultH;
    }

    public async Task ToggleColor(SKColorChannel channel)
    {
        switch(channel)
        {
            case SKColorChannel.R:
                isRed = ! isRed;
                break;
            case SKColorChannel.G:
                isGreen = ! isGreen;
                break;
            case SKColorChannel.B:
                isBlue = ! isBlue;
                break;
        }
        await RedrawHistogram();
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

@code{
    /*
     * @using Radzen.Blazor
@inject StateService SService
@inject ImageProcessing ImageProc

@if(dataIsSet)
{
    <p class="fs-6 fw-bold m-2">Histogram</p>
    <div class="input-group m-2 w-75">
        <span class="input-group-text">Channel:</span>
        <select @onchange="OnChannelChosen" class="form-select">
            @*<option value="null" disabled selected>Choose filter</option>*@
            <option value=@SKColorChannel.R selected>Red</option>
            <option value=@SKColorChannel.G>Green</option>
            <option value=@SKColorChannel.B>Blue</option>
        </select>
    </div>

    <div class="w-100 border border-success ps-2 my-2">
	    <RadzenChart ColorScheme="ColorScheme.Monochrome" Style="width: 100%; aspect-ratio: 16/9; height: auto;">
          <RadzenColumnSeries Data="@histogram" CategoryProperty="Value" StrokeWidth="1" ValueProperty="Count"
              Stroke="@barColor" Fill="@barColor">
              <TooltipTemplate Context="data">
                  <div>
                    Value: <strong>@data.Value</strong>
                    <br />
                    % of values: <strong>@Percent(data.Count)</strong>%
                  </div>
              </TooltipTemplate>
          </RadzenColumnSeries>
  
          <RadzenCategoryAxis Max="255" Step="50">
          </RadzenCategoryAxis>
  
          <RadzenValueAxis Min="0" Step="@step" Formatter="@Percent">
              <RadzenGridLines Visible="true"/>
          </RadzenValueAxis>

          <RadzenLegend Visible="false" />
        </RadzenChart>
    </div>
}

@code {

    class HistogramItem
    {
        public byte Value { get; set; }
        public int Count { get; set; }
    }

    HistogramItem[] histogram;
    int pixelsLength;
    int step;
    bool dataIsSet = false;
    SKColorChannel channel = SKColorChannel.R;
    string barColor = colorRed;
    static string colorRed = "rgba(255, 0, 0, 0.5)";
    static string colorGreen = "rgba(0, 255, 0, 0.5)";
    static string colorBlue = "rgba(0, 0, 255, 0.5)";

    //[Parameter]
    //public int[] HistogramArray { get; set; }        

    private string Percent(int value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private string Percent(object value)
    {
        //Console.WriteLine($"{value}, {pixelsLength}, {Math.Round((double)value / pixelsLength * 100)}");
        return Math.Round((double)value / pixelsLength * 100, 2).ToString();
    }

    private HistogramItem[] GetHistogram(byte[] pixels)
    {
        HistogramItem[] resultH = new HistogramItem[256];

        int[] array = new int[256];
        for (int i = 0; i < pixels.Length; i++)
        {
            array[pixels[i]]++;
        }

        //step = array.Max() / 4;

        for (int i = 0; i < resultH.Length; i++)
        {
            resultH[i] = new HistogramItem
            {
                Value = (byte)i,
                Count = array[i]
                //Count = (int)Math.Round((float)array[i] / pixelsLength * 100)
            };
        }

        return resultH;
    }

    private async Task RedrawHistogram()
    {
        await SetData();
        StateHasChanged();
    }

    private async Task SetData()
    {
        byte[] pixels;
        switch(channel)
        {
            case SKColorChannel.R:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
            case SKColorChannel.G:
                pixels = SService.bitmap.Pixels.Select(x => x.Green).ToArray();
                barColor = colorGreen;
                break;
            case SKColorChannel.B:
                pixels = SService.bitmap.Pixels.Select(x => x.Blue).ToArray();
                barColor = colorBlue;
                break;
            default:
                pixels = SService.bitmap.Pixels.Select(x => x.Red).ToArray();
                barColor = colorRed;
                break;
        }
        pixelsLength = pixels.Length;
        histogram = GetHistogram(pixels);
        //step = histogram.Select(x => x.Count).Max() / 4;
        //step = histogram.Max(x => x.Count) / 4;
        step = (int)Math.Ceiling(histogram.Max(x => x.Count) / 4d);
        dataIsSet = true;
    }

    public async Task OnChannelChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out SKColorChannel enumVal))
            {
                channel = enumVal;
                await RedrawHistogram();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        SService.RedrawHistogram += RedrawHistogram;
    }
}

     */
}
