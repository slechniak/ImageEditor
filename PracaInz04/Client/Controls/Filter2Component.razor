@using static PracaInz04.Client.ImageProcessingClasses.ImageProcessing
@inject StateService SService
@inject ImageProcessing ImageProc

<p class="fs-6 fw-bold m-2">Filters</p>
<div class="input-group m-2 w-75">
    <span class="input-group-text">Filter:</span>
    @*<select @bind="filterType" class="form-select">*@
    <select @onchange="OnFilterChosen" class="form-select">
        @*<option value="null" disabled selected>Choose filter</option>*@
        <option value="" selected>None</option>
        @foreach(var fType in filterTypeList)
        {
            @*<option value=@fType>@((FilterType)fType == FilterType.EqualizeHistogram ? "Equalize histogram" : fType)</option>*@
            <option value=@fType>
                @switch((FilterType)fType)
                {
                    case FilterType.EqualizeHistogram:
                        @:Equalize histogram
                        break;
                    case FilterType.StretchHistogram:
                        @:Stretch histogram
                        break;
                    case FilterType.EdgeDetect:
                        @:Edge detection
                        break;
                    default:
                        @fType
                        break;
                }
            </option>
        }
    </select>
</div>

@if(filterType == FilterType.Binary)
{
    <label for="customRange1" class="form-label pt-2 px-2">Treshold</label>
    <input 
        value="@treshold" @oninput="OnTresholdChange"
        min="@minTreshold" max="@maxTreshold"
        type="range" class="form-range m-2 w-75" id="customRange1">
    <input 
        value="@treshold" @onchange="OnTresholdChange"
        type="number" class="form-control m-2 w-25" id="formControlInput1">
}
@if(filterType == FilterType.Brightness)
{
    <label for="customRange2" class="form-label pt-2 px-2">Level</label>
    <input 
        value="@level" @oninput="OnLevelChange"
        min="@minLevel" max="@maxLevel"
        type="range" class="form-range m-2 w-75" id="customRange2">
    <input 
        value="@level" @onchange="OnLevelChange"
        type="number" class="form-control m-2 w-25" id="formControlInput2">
}
@if(filterType == FilterType.Contrast)
{
    <label for="customRange3" class="form-label pt-2 px-2">Factor</label>
    <input 
        value="@factor" @oninput="OnFactorChange"
        min="@minFactor" max="@maxFactor"
        type="range" class="form-range m-2 w-75" id="customRange3">
    <div class="form-check m-2">
        <input class="form-check-input" type="checkbox" value="@inColor" id="flexCheckChecked"
            @onchange="OnInColorChange">
        <label class="form-check-label" for="flexCheckChecked">Color</label>
    </div>
    <input 
        value="@factor" @onchange="OnFactorChange"
        type="number" class="form-control m-2 w-25" id="formControlInput3">
}
@if(filterType == FilterType.StretchHistogram)
{
    <label for="customRange4" class="form-label pt-2 px-2">Percentile cut</label>
    <input 
        value="@cutoff" @oninput="OnCutoffChange"
        min="@minCutoff" max="@maxCutoff"
        type="range" class="form-range m-2 w-75" id="customRange4">
    <input 
        value="@cutoff" @onchange="OnCutoffChange"
        type="number" class="form-control m-2 w-25" id="formControlInput4">
}
@if(filterType == FilterType.Average)
{
    <label for="customRange5" class="form-label pt-2 px-2">Kernel size: @kernelSize</label>
    <input 
        value="@kernelSize" @oninput="OnKernelSizeChange"
        min="@minKernel" max="@maxKernel" step="2"
        type="range" class="form-range m-2 w-75" id="customRange5">
    @*<input 
        value="@kernelSize" @onchange="OnKernelSizeChange" step="2"
        type="number" class="form-control m-2 w-25" id="formControlInput5">*@
}
@if(filterType == FilterType.Gaussian)
{
    <label for="customRange6" class="form-label pt-2 px-2">Kernel size: @kernelSize</label>
    <input 
        value="@kernelSize" @oninput="OnKernelGaussChange"
        min="@minKernelGauss" max="@maxKernelGauss" step="2"
        type="range" class="form-range m-2 w-75" id="customRange6">
    @*<input 
        value="@kernelSize" @onchange="OnKernelSizeChange" step="2"
        type="number" class="form-control m-2 w-25" id="formControlInput5">*@
}
<button @onclick="ApplyFilter" class="btn btn-primary">Save changes</button>

@code {
    [Parameter]
    public EventCallback<SKBitmap> AddBitmap { get; set; }
    [Parameter]
    public EventCallback<SKBitmap> ShowBitmap { get; set; }
    public Array filterTypeList;
    public FilterType? filterType;
    public int treshold = 128;
    public int minTreshold = 0;
    public int maxTreshold = 255;

    public int level = 0;
    public int minLevel = -255;
    public int maxLevel = 255;

    public int factor = 0;
    //public int minFactor = 0;
    //public int minFactor = -100;
    //public int maxFactor = 100;
    //public bool inColor = true;
    public int minFactor = -255;
    public int maxFactor = 255;
    public bool inColor = false;

    public int cutoff = 0;
    public int minCutoff = 0;
    public int maxCutoff = 49;

    public int kernelSize = 3;
    public int minKernel = 1;
    public int maxKernel = 11;

    public int minKernelGauss = 3;
    public int maxKernelGauss = 5;

    SKBitmap result;

    // <text>Equalize histogram</text> == @:Equalize histogram

    public async Task ApplyFilter()
    {
        await FilterAndShow();
        await AddBitmap.InvokeAsync(result);
    }

    public async Task ShowPixels(SKBitmap bitmap, string title)
    {
        SKColor[] pixels = bitmap.Pixels;
        int k = 0;
        string str = title;
        string toCopy = "";
        for (int i = 0; i < bitmap.Width; i++)
        {
            for (int j = 0; j < bitmap.Height; j++)
            {
                str += $"[{i},{j}]:{pixels[k].Red}, ";
                toCopy += $"{pixels[k].Red}+";
                k++;
            }
            str += "\n";
            toCopy += ";";
        }
        Console.WriteLine(str);
        Console.WriteLine(toCopy);
    }

    public async Task FilterAndShow()
    {
        //result = SService.bitmap;
        result = SService.bitmap.Copy();
        //SKColor color = result.GetPixel(0, 0);
        //Console.WriteLine($"before RGBA: ({color.Red}, {color.Green}, {color.Blue}, {color.Alpha})");
        switch (filterType)
        {
            case ImageProcessing.FilterType.Grayscale:
                //result = ImageProc.FilterGrayscale(SService.bitmap);
                result = ImageProc.FilterGrayscale(result);
                break;
            case ImageProcessing.FilterType.Binary:
                //result = ImageProc.FilterBinary(SService.bitmap, treshold);
                result = ImageProc.FilterBinary(result, treshold);
                break;
            case ImageProcessing.FilterType.Brightness:
                //result = ImageProc.FilterBrightness(SService.bitmap, level);
                result = ImageProc.FilterBrightness(result, level);
                break;
            case ImageProcessing.FilterType.Contrast:
                //result = ImageProc.FilterContrast(SService.bitmap, factor, inColor);
                result = ImageProc.FilterContrast(result, factor, inColor);
                break;
            case ImageProcessing.FilterType.EqualizeHistogram:
                //result = ImageProc.EqualizeHistogram(SService.bitmap);
                result = ImageProc.EqualizeHistogram(result);
                break;
            case ImageProcessing.FilterType.StretchHistogram:
                //result = ImageProc.StretchHistogram(SService.bitmap, cutoff);
                result = ImageProc.StretchHistogram(result, cutoff);
                break;
            case ImageProcessing.FilterType.Average:
                //result = ImageProc.StretchHistogram(SService.bitmap, cutoff);
                //await ShowPixels(result, "before: ");
                result = ImageProc.FilterAverage(result, kernelSize);
                //await ShowPixels(result, "after: ");
                break;
            case ImageProcessing.FilterType.Sharpen:
                //result = ImageProc.StretchHistogram(SService.bitmap, cutoff);
                result = ImageProc.FilterSharpen(result);
                break;
            case ImageProcessing.FilterType.Gaussian:
                //result = ImageProc.StretchHistogram(SService.bitmap, cutoff);
                result = ImageProc.FilterGaussian(result, kernelSize);
                break;
            case ImageProcessing.FilterType.EdgeDetect:
                //result = ImageProc.StretchHistogram(SService.bitmap, cutoff);
                result = ImageProc.FilterEdgeDetect(result);
                break;
        }
        //color = result.GetPixel(0, 0);
        //Console.WriteLine($"after RGBA: ({color.Red}, {color.Green}, {color.Blue}, {color.Alpha})");
        await ShowBitmap.InvokeAsync(result);
    }

    protected override void OnInitialized()
    {
        //result = SService.bitmap;
        result = SService.bitmap?.Copy();
        filterTypeList = Enum.GetValues(typeof(FilterType));
    }

    public async Task OnFilterChosen(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            if(Enum.TryParse((string)e.Value, out FilterType enumVal))
            {
                filterType = enumVal;
                SService.newBitmap = true;
                await FilterAndShow();
            }
            else
            {
                filterType = null;
                //await ShowBitmap.InvokeAsync(SService.bitmap);
                await ShowBitmap.InvokeAsync(SService.bitmap.Copy());
            }
        }
    }

    private async Task OnTresholdChange(ChangeEventArgs e)
    {
        treshold = Convert.ToInt32(e.Value);
        //treshold = Math.Min(treshold, maxTreshold);
        //treshold = Math.Max(treshold, minTreshold);
        treshold = Math.Clamp(treshold, minTreshold, maxTreshold);
        await FilterAndShow();
    }

    private async Task OnLevelChange(ChangeEventArgs e)
    {
        level = Convert.ToInt32(e.Value);
        //level = Math.Min(level, maxLevel);
        //level = Math.Max(level, minLevel);
        level = Math.Clamp(level, minLevel, maxLevel);
        await FilterAndShow();
    }

    private async Task OnFactorChange(ChangeEventArgs e)
    {
        factor = Convert.ToInt32(e.Value);
        //factor = Math.Min(factor, maxFactor);
        //factor = Math.Max(factor, minFactor);
        factor = Math.Clamp(factor, minFactor, maxFactor);
        await FilterAndShow();
    }

    private async Task OnCutoffChange(ChangeEventArgs e)
    {
        cutoff = Convert.ToInt32(e.Value);
        //factor = Math.Min(factor, maxFactor);
        //factor = Math.Max(factor, minFactor);
        cutoff = Math.Clamp(cutoff, minCutoff, maxCutoff);
        await FilterAndShow();
    }

    private async Task OnKernelSizeChange(ChangeEventArgs e)
    {
        kernelSize = Convert.ToInt32(e.Value);
        //factor = Math.Min(factor, maxFactor);
        //factor = Math.Max(factor, minFactor);
        kernelSize = Math.Clamp(kernelSize, minKernel, maxKernel);
        if (kernelSize % 2 != 0)
            await FilterAndShow();
        else
            Console.WriteLine($"even kernel size {kernelSize}");
    }

    private async Task OnKernelGaussChange(ChangeEventArgs e)
    {
        kernelSize = Convert.ToInt32(e.Value);
        //factor = Math.Min(factor, maxFactor);
        //factor = Math.Max(factor, minFactor);
        kernelSize = Math.Clamp(kernelSize, minKernelGauss, maxKernelGauss);
        if (kernelSize % 2 != 0)
            await FilterAndShow();
        else
            Console.WriteLine($"even kernel size {kernelSize}");
    }

    private async Task OnInColorChange(ChangeEventArgs e)
    {
        inColor = !inColor;
        if(inColor)
        {
            minFactor = -100;
            maxFactor = 100;
        }
        else
        {
            minFactor = -255;
            maxFactor = 255;
        }
        SService.newBitmap = true;
        factor = 0;
        //StateHasChanged();
        await FilterAndShow();
    }
}